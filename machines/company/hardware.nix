# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{
  config,
  lib,
  pkgs,
  ...
}:

let

  sambaSopsOpts = {
    sopsFile = ../../secrets/samba_credentials.yaml;
  };
  secrets = {
    samba_env = sambaSopsOpts // {
      key = "environmentVariables";
    };
    samba_credentials = sambaSopsOpts // {
      key = "credentials";
    };
  };

in

{
  boot = {
    initrd.availableKernelModules = [
      "xhci_pci"
      "ahci"
      "nvme"
      "usbhid"
      "usb_storage"
      "rtsx_usb_sdmmc"
    ];
    initrd.kernelModules = [ ];
    kernelModules = [ "kvm-intel" ];
    extraModulePackages = [ ];

    loader = {
      # use GRUB2 as boot loader
      grub = {
        enable = true;
        device = lib.mkDefault "nodev";
        efiSupport = true;
        # In this case boot.loader.efi.canTouchEfiVariables not work with removable ESP
        efiInstallAsRemovable = true;
      };

      # In this case, we should also set the boot.loader.efi.efiSysMountPoint to /boot/efi as well.
      efi.efiSysMountPoint = "/boot/efi";
    };
  };

  fileSystems = {
    "/" = {
      device = "/dev/disk/by-label/nixos";
      fsType = "ext4";
    };

    # Mount ESP to /boot/efi instead of /boot
    # Ref: https://nixos.wiki/wiki/Bootloader#Limiting_amount_of_entries_with_grub_or_systemd-boot
    "/boot/efi" = {
      device = "/dev/disk/by-label/boot";
      fsType = "vfat";
    };

    "/mnt/data" = {
      device = "/dev/disk/by-label/Data";
      fsType = "ext4";
    };
  };

  # Windows Share
  # For mount.cifs, required unless domain name resolution is not needed.
  environment.systemPackages = [ pkgs.cifs-utils ];
  sops.secrets = secrets;

  systemd.services."mount-smb" =
    let
      mountPoint = "/mnt/smbmount";
    in
    {
      description = "Mount SMB share using SOPS secrets";
      after = [
        "network-online.target"
        "sops-nix.service"
      ];
      wants = [ "network-online.target" ];
      wantedBy = [ "multi-user.target" ];
      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        EnvironmentFile = config.sops.secrets.samba_env.path;
        ExecStart = pkgs.writeShellScript "mount-smb" ''
          set -a
          if [ ! -d ${mountPoint} ]; then
            mkdir -p ${mountPoint}
          fi
          /run/current-system/sw/bin/mount -t cifs "//$SMB_HOST/$SMB_SHARE" ${mountPoint} -o ${
            lib.strings.concatStringsSep "," [
              "credentials=${config.sops.secrets.samba_credentials.path}"
              "vers=3.0"
              # uid and gid can be name or id
              "uid=${config.users.users.maiko.name}"
              "gid=${config.users.users.maiko.group}"
              "file_mode=0644"
              "dir_mode=0755"
            ]
          }
        '';
        ExecStop = "/run/current-system/sw/bin/umount ${mountPoint}";
      };
    };

  # Enable zram swap for better performance on systems with low RAM
  zramSwap = {
    enable = true;
    memoryPercent = 150;
    algorithm = "zstd";
    priority = 100;
  };

  boot.kernel.sysctl = {
    # Increase swappiness to use swap more aggressively
    "vm.swappiness" = 120;
    "vm.vfs_cache_pressure" = 100;
  };

  swapDevices = [
    # create a 8 GB swap file
    {
      device = "/swapfile";
      size = 8 * 1024;
    }
  ];

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  powerManagement.cpuFreqGovernor = lib.mkDefault "powersave";
  hardware = {
    enableRedistributableFirmware = true;

    firmware = [
      pkgs.linux-firmware
    ];

    cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
  };
}
