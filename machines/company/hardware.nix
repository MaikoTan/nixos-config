# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{
  config,
  lib,
  pkgs,
  ...
}:

let

  sambaSopsOpts = {
    sopsFile = ../../secrets/samba_credentials.yaml;
  };
  secrets = {
    samba_env = sambaSopsOpts // {
      key = "environmentVariables";
    };
    samba_credentials = sambaSopsOpts // {
      key = "credentials";
    };
  };

in

{
  boot.initrd.availableKernelModules = [
    "xhci_pci"
    "nvme"
    "usbhid"
    "rtsx_usb_sdmmc"
  ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" ];
  boot.extraModulePackages = [ ];

  # use GRUB2 as boot loader
  boot.loader.grub = {
    enable = true;
    device = lib.mkDefault "nodev";
    efiSupport = true;
  };

  fileSystems."/" = {
    device = "/dev/disk/by-label/nixos";
    fsType = "ext4";
  };

  # Mount ESP to /boot/efi instead of /boot
  # Ref: https://nixos.wiki/wiki/Bootloader#Limiting_amount_of_entries_with_grub_or_systemd-boot
  fileSystems."/boot/efi" = {
    device = "/dev/disk/by-label/boot";
    fsType = "vfat";
  };

  # In this case, we should also set the boot.loader.efi.efiSysMountPoint to /boot/efi as well.
  boot.loader.efi.efiSysMountPoint = "/boot/efi";
  # In this case boot.loader.efi.canTouchEfiVariables not work with removable ESP
  boot.loader.grub.efiInstallAsRemovable = true;

  fileSystems."/mnt/data" = {
    device = "/dev/disk/by-label/Data";
    fsType = "ext4";
  };

  # Windows Share
  # For mount.cifs, required unless domain name resolution is not needed.
  environment.systemPackages = [ pkgs.cifs-utils ];
  sops.secrets = secrets;

  systemd.services."mount-smb" = {
    description = "Mount SMB share using SOPS secrets";
    after = [ "network-online.target" "sops-nix.service" ];
    wants = [ "network-online.target" ];
    wantedBy = [ "multi-user.target" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      EnvironmentFile = config.sops.secrets.samba_env.path;
      ExecStart = pkgs.writeShellScript "mount-smb" ''
        set -a
        if [ ! -d /mnt/smbmount ]; then
          mkdir -p /mnt/smbmount
        fi
        /run/current-system/sw/bin/mount -t cifs "//$SMB_HOST/$SMB_SHARE" /mnt/smbmount -o ${lib.strings.concatStringsSep "," [
          "credentials=${config.sops.secrets.samba_credentials.path}"
          "vers=3.0"
          "uid=1000"
          "gid=1000"
          "file_mode=0777"
          "dir_mode=0777"
        ]}
      '';
      ExecStop = "/run/current-system/sw/bin/umount /mnt/smbmount";
    };
  };

  # Enable zram swap for better performance on systems with low RAM
  zramSwap = {
    enable = true;
    memoryPercent = 150;
    algorithm = "zstd";
    priority = 100;
  };

  boot.kernel.sysctl = {
    # Increase swappiness to use swap more aggressively
    "vm.swappiness" = 120;
    "vm.vfs_cache_pressure" = 100;
  };

  swapDevices = [
    # create a 8 GB swap file
    {
      device = "/swapfile";
      size = 8 * 1024;
    }
  ];

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  powerManagement.cpuFreqGovernor = lib.mkDefault "powersave";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
